
\subsection{Theoretical Background}
The approach of generic programming can was defined by two different directions. One is the “gradual lifting of concrete algorithms” \cite{Reis:2005} and was brought up by \citep{Musser:1988}. The idea is to take a pragmatic algorithm and transform it gradual into a more abstract version without losing efficiency or semantics. This methodology is coming from the imperative languages, where C++/Java are playing a dominant role nowadays.

The second school a calculational approach, often also referred to as Datatype-Generic programming \cite{Gibbons:2006}. \citep{Bird:1998} were the ones who created the basis with their work. The focus is on regular data types by exploiting algebras generated by functors sum, product and unit. Thus, it is possible to operate any inductive datatype, if the algorithms are written for those functors.  In contrary to the first approach has Datatype-Generic programming Haskell and its variants as the most exclusive tool.

Due to the object oriented language type from KOOL and the close relationship from this language to Java, we decided to use the first approach for our generics extension.

Our generics extension, like Java, uses type erasure. This means that the generic types are checked at compile time and then replaced with Object. This limits generics to classes. Primitive types like boolean and int are not allowed. This made the implementation easier but makes the language less powerful.

\subsection{Implementation Details}

\begin{description}
\item[\textcolor{Gray}{Lexer}] \hfill \\
Our changes are stated in the table below. Most of the changes were made in the grammar. The lexer already supported tokens for identifiers and braces.

\begin{table}[h!]
  \begin{tabular}{|l|c|p{4.1cm}|}
    \hline
    Type             & ::= & Identifier [ GenericType ] ;          \\ \hline
    ClassDeclaration & ::= & class Identifier \newline ([Identifier])? .... \\ \hline
    GenericType      & ::= & String $\vert$ Identifier   \\ \hline
  \end{tabular}
\end{table}

\item[\textcolor{Gray}{Parser}] \hfill \\
The parser needs to recognize the new grammar and add the optional identifier to the ClassDecl object. The parser must also accept the old grammar, because the new grammar is a superset of the old one with the generic type being optional. Note that this grammar is, in contrast to java, limited to only one generic type per class. The parser checks that the generic type is either identifier or string since we do not allow primitive types. The changes we made looks like this:

\begin{lstlisting}
def parseGenericIdentifier: Identifier = {
  val pos = currentPos
  val identifier: Identifier = parseIdentifier
  var genericType: Option[TypeTree] = None
  if (currentToken.kind == LBRACKET) {
    eat(LBRACKET)
    val pos2 = currentPos
    genericType = currentToken.kind match {
      case STRING =>
        eat(STRING)
        Some((new StringType).setPos(pos2))
      case IDKIND =>
        Some(parseGenericIdentifier)
      case _ =>
        error("Primitive types not allowed for generics", pos2)
        readToken
        None
    }
    eat(RBRACKET)
  }
  identifier.genericType = genericType
  identifier.setPos(pos)
}
\end{lstlisting}

Which can be explained as follows: If an identifier is followed by a left bracket. Parse the generic identifier that follows. As shown in the code, only STRING and Identifier are valid types to be used as generic types.

\item[\textcolor{Gray}{Name Analyser}] \hfill \\
The name analyzer has to make sure the generic class identifier is only used inside that class. When implementing the compiler we made sure every reference to the same class had the same symbol. This meant we could not attach the generic type to the symbol. What we did instead was create a new symbol GenericSymbol which is attached to every reference to the generic identifier inside the class. We then added a field to the TObject type to allow it to take a type in addition to a class symbol. This means we could check the type of the object when doing method calls or return statements. The changes are illustrated below.

\begin{lstlisting}
def handleGenerics(cd: ClassDecl, cs: ClassSymbol) =
cd.id.genericType match {
  case Some(t) =>
    t match {
      case Identifier(v,_) =>
        var gs = new GenericSymbol(v)
        gs.setType(TGeneric(gs))
        gs.setPos(cd.id)
        cs.genericSymbol = Some(gs)
      case _ =>
    }
  case None =>
}
\end{lstlisting}

In the code above, if we have a generic identifier for this class, create a generic symbol.

The generic symbol is attached like this:

\begin{lstlisting}
def setTypeSymbol(tpe: TypeTree, cs: ClassSymbol) {
  tpe match {
    case id: Identifier => {
      // ... 
        case None =>
          cs.genericSymbol match {
            case Some(gs) =>
              if (id.value == gs.name)
                id.setSymbol(gs)
            case None =>
              error("Class not declared", tpe)
          }
      }
    } case _ =>
  }
}
\end{lstlisting}

In the code above, if we haven't found a class with a matching name, we check if the identifier is the generic identifier. If it is, we assign the generic symbol.

This is how it is used in practice

\begin{lstlisting}
class A[T] {
  var t: T;

  def meth(q: T): String = {
    // ...
  }
}
\end{lstlisting}

In the code above, T would get assigned a a GenericSymbol which has the type TGeneric. When using generics in an object the code looks like this:

\begin{lstlisting}
println(new A[String]().meth("text"));
\end{lstlisting}

In this code, the identifier A is parsed as a generic identifier by the parser. This means it has the type TObject(classSymbol, StringType()). In the type checker, we'll use the two fields of TObject to type check the generic parameters.

\item[\textcolor{Gray}{Type checker}] \hfill \\
In the type checker we use our extended TObject type to make sure that the second parameter in TObject (string in the example above), matches the argument passed to a method which takes a generic argument. Our code for doing that looks like this:

\begin{lstlisting}
if (a(i).toString == "generic") {
  mc.obj.getType match {
    case TObject(_,Some(t)) =>
    if(mc.args(i).getType != t.getType) {
      var err: String = "Type error: expected: " +
      t.getType + " found: " + mc.args(i).getType
      error(err, mc.args(i))
    }
    case _ =>
  }
} else {
  mc.args(i).setType(tcExpr(mc.args(i), a(i)))
}
\end{lstlisting}

Which can be read like this: If the parameter is generic, see if the generic type of the object is the same as our argument. As shown in the listing above, the normal type checking procedure (tcExpr) is not used for generic arguments. In addition to checking method arguments we also have to check the methods return type whenever it is generic. This is done as follows (in tcExpr)

\begin{lstlisting}
case mc: MethodCall =>
  mc.setType(tcMethCall(mc))
  mc.obj.getType match {
    case TObject(cs,Some(t)) =>
      generic = true
      if (!expected.isEmpty &&
          !expected.contains(typeTreeToType(t,cs)))
        error("Type error", mc)
    case _ =>
  }
  mc.getType
\end{lstlisting}

Which means that if the method return type is generic (indicated by the fact that it has a second argument in TObject), see if it is one of the expected types. $generic = true$ is used to bypass the regular typechecking which is done in tcExpr. This is because the type of the method is still TGeneric. An example of how this is used is given below. Keeping TGeneric here means we have to implement a few special cases. However, it makes the code generation much easier as we'll se later.

A more complete example:

\begin{lstlisting}
class A[T] {
  def meth(t: T): T = {
    return t;
  }
}

//.... usage

println(new A[String]().meth("ok"));

//.. stdout: ok
\end{lstlisting}

In this code, t and T in A will have the type TGeneric, new A[String]() will have type TObject(ClassSymbol, StringType()) and "ok" will of course have type TString. This is assigned by the name analyzer. In the type checker we'll see that meth takes a generic parameter. When the type checker notices this it checks the method calling object for a generic type (stored in TObject). This is compared to the type of "ok". Since both are string we are OK. When type checking the argument to println we provide a number of types that are allowed (TString, TBoolean, TInt). The type checker will compare the expected types to the type stored in TObject. Since the generic type is String and this is allowed for println, the check goes through.

Another special case is the plus operator. It is only allowed with int or string. This is solved by telling tcExpr to expect Int or String. It doesn't matter if the objects involved are generic or not as our code uses the expected values for method calls in both cases. However, since Int is not allowed. If generic types are involved the result must be string. This is what our code looks like:

\begin{lstlisting}
def tcPlus(p: Plus): Type = {
  p.lhs.setType(tcExpr(p.lhs, TString, TInt))
  p.rhs.setType(tcExpr(p.rhs, TString, TInt))
  if (p.lhs.getType == TInt &&
      p.rhs.getType == TInt) TInt
  else if (p.lhs.getType == TInt &&
           p.rhs.getType == TString) TString
  else if (p.lhs.getType == TString &&
           p.rhs.getType == TInt) TString
  else if (p.lhs.getType == TString &&
           p.rhs.getType == TString) TString
  else if (p.lhs.getType.toString == "generic" ||
           p.rhs.getType.toString == "generic") {
    TString
  } else {
    error("Cannot use + on " + p.lhs.getType +
          " and " + p.rhs.getType, p)
    TError
  }
}
\end{lstlisting}

\item[\textcolor{Gray}{Code Generation}] \hfill \\
Since we only allow strings and objects the code generation has a really easy job. It needs to convert all the TGenerics to Object. This is done with the following code:

\begin{lstlisting}
def typeToByteCode(tpe: Type): String = tpe match {
  case TString => "Ljava/lang/String;"
  case TInt => "I"
  case TBoolean => "Z"
  case TIntArray => "[I"
  case TObject(v,_) => "L" + v.name + ";"
  case TGeneric(_) => "Ljava/lang/Object;";
  case TError | TUntyped => ""
}
\end{lstlisting}

\end{description}
